{"meta":{"title":"迷你盒","subtitle":"尘世间迷途小码农一枚","description":"技术博客 IT JAVA 互联网","author":"Mickole Chou","url":"https://minibox.coding.me"},"pages":[{"title":"404","date":"2017-04-17T02:08:21.482Z","updated":"2017-04-17T02:08:21.482Z","comments":true,"path":"/404.html","permalink":"https://minibox.coding.me//404.html","excerpt":"","text":"404"},{"title":"Categories","date":"2017-04-17T02:08:21.493Z","updated":"2017-04-17T02:08:21.493Z","comments":true,"path":"categories/index.html","permalink":"https://minibox.coding.me/categories/index.html","excerpt":"","text":""},{"title":"About me","date":"2017-04-24T10:20:00.982Z","updated":"2017-04-24T10:20:00.982Z","comments":true,"path":"about/index.html","permalink":"https://minibox.coding.me/about/index.html","excerpt":"","text":"一个人在梦游，像奔跑的蜗牛，不到最后不罢休。 I’m a 程序猿，one day 我坐在路边一边喝水一边苦苦check bug。这时一个乞丐在我边上坐下了，开始要饭，我觉得可怜，就给了他1块钱，然后接着调试程序。他可能生意不好，就无聊的看看我在干什么，然后过了一会，他幽幽的说，这里少了个分号。。。分号。。。分号。。。"},{"title":"Tags","date":"2017-04-17T02:08:21.498Z","updated":"2017-04-17T02:08:21.498Z","comments":true,"path":"tags/index.html","permalink":"https://minibox.coding.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo icarus主题小功能设置","slug":"Hexo-icarus主题小功能设置","date":"2016-04-29T03:05:56.000Z","updated":"2017-04-26T05:54:56.284Z","comments":true,"path":"2016/04/29/Hexo-icarus主题小功能设置/","link":"","permalink":"https://minibox.coding.me/2016/04/29/Hexo-icarus主题小功能设置/","excerpt":"添加站长统计我们通过站长统计来及时查看我们个人网站的浏览情况。首先，我们需要进行注册：站长统计以下参考：添加cnzz站长统计","text":"添加站长统计我们通过站长统计来及时查看我们个人网站的浏览情况。首先，我们需要进行注册：站长统计以下参考：添加cnzz站长统计 在theme的_config.yml中的末尾添加以下：(这部很重要，不添加web_id将无法显示出来)12# CNZZ idcnzz: 这里填入你在站长统计注册后的web_id 在目录：主题的layout/_partial/添加文件为cnzz.ejs，内容如下：123&lt;% if (theme.cnzz)&#123; %&gt;Analyse with &lt;script src=\"https://s4.cnzz.com/z_stat.php?id=&lt;%= theme.cnzz %&gt;&amp;web_id=&lt;%= theme.cnzz %&gt;\" language=\"JavaScript\"&gt;&lt;/script&gt;&lt;% &#125; %&gt; 注意:一定要采用https方式引入，否则chrome浏览器考虑安全性问题不会加载 最后进行显示，在路径layout/_partial/footer.ejs里面添加： 1...PPOffice&lt;/a&gt;.&lt;%- partial(&apos;cnzz&apos;) %&gt; 再次提醒注意在_config.xml中添加web_id，否则无法显示。当显示出来了，又有一个问题，那就是要填写查看密码了。查看以下即可：【设置】如何设置查看密码？（此功能只限站长用户） 百度/谷歌验证站点为什么要验证站点了，因为要搜索引擎进行收录，说白了就是让别人更容易搜索到你的网站，仅此而已。首先需要到百度/谷歌站长统计中注册，以及验证：Google网站管理员工具地址百度站长工具注册完后，进行输入相应的网站地址，然后选择html验证，将代码加入以下路径layout/_partial/head.ejs：（截取部分） 12345&lt;head&gt; &lt;meta name=\"baidu-site-verification\" content=\"tqvy7RDErf\" /&gt; &lt;meta name=\"google-site-verification\" content=\"hjN29-PO_KfE-dgow-7hcz75xJj0qzZ6G2OkXZ3FVd8\" /&gt; &lt;meta charset=\"utf-8\"&gt; .... 然后发布到github中，再进行验证即可。 百度分享按钮https站点不显示问题在主题中设置百度分享按钮之后发现一个问题，就是部署到github page之后不显示，但本地测试可以。之后F12调试，发现百度分享采用的是http，而github page则是https，chrome浏览器考虑安全问题，不允许加载导致线上百度分享按钮脚本未能加载。 解决方案要让https站点加载，很简单，将百度分享脚本存放到可支持https的站点即可。这里我直接将百度分享脚本放到hexo的source目录下（hexo根目录的source下或者主题的source下都可以） 百度分享脚本可在一下地址下载：百度分享脚本下载之后解压，将static文件夹复制到source目录下即可。 然后找到主题中引用百度分享脚本的地方，我用的是icarus主题，则在themes\\icarus\\layout\\share目录下的bdshare.ejs文件。修改改文件：123.src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt;改为.src=&apos;/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 以上步骤完成，搞定。 hexo添加公益404创建404页面首先在博客根目录的source目录下创建404.md文件然后你可以将页面设计成自己喜欢的样式与主题搭配或直接使用公益404页面。公益404一般有以下两个选择： 腾讯404 益播404这里我直接采用腾讯公益404，使用方式可参考腾讯404说明。在404.md中添加一下内容：12345678910111213---title: 404layout: falsepermalink: /404.html---&lt;html&gt; &lt;head&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;https://minibox.coding.me&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意：一定记得在Front-matter添加layout: false，否则会使用默认layout进行页面渲染。homePageUrl改成你blog地址即可。 测试是否正常需部署到github或你服务器之后才能，本地部署不行。 添加音乐播放器想像一下，一边欣赏博客一边欣赏音乐是不是一件很美好的事情。 添加网易云音乐播放器给hexo博客添加音乐播放器最简单最优雅的方式就是通过网易云音乐生成外链，引入自己博客即可，具体步骤如下： 在网易云音乐pc端找到你喜欢的单曲或歌单，点击生成外链： 进入生成外链页 可自定义播放器尺寸，选择是否自动播放，然后复制红框中外链代码放入hexo博客即可。是不是很简单呢，但是有个问题，网易云外链播放器暂时不支持https，所以如果你的博客是https站点，引入网易云音乐播放器后，你那可爱的小绿锁就没了，所以，是否引入自己考量。 支持https的音乐播放器目前支持https的音乐播放器太少，找了好久才找到以下方式：通过该项目插件可在博客引入支持https的音乐播放器。其内部也是基于网易云音乐实现。简单做法就是在iframe标签中引入该插件提供的http连接即可，如下示例：12&lt;iframe src=&quot;https://music.daoapp.io/iframe?song=287749&amp;qssl=1&amp;qlrc=1&amp;qnarrow=0&amp;max_width=50%&amp;autoplay=1&quot;&gt;&lt;/iframe&gt; 即将iframe标签的src属性值设置为插件提供的https连接即可。 该插件支持配置多个参数如，自动播放，大小尺寸，播放模式等，支持参数如下： album=album_id playlist=playlist_id song=song_id program=program_id radio=radio_id mv=mv_id qssl=[0|1] default:0 qlrc=[0|1] default:0 qnarrow=[0|1] default:0 max_width=[100%|32rem|400px|something else] default:100% max_height=[300px|something else] default:100% autoplay=[0|1] default:1 mode=[random|single|circulation|order] default:circulation 只需将参数加入url后面即可，具体做法参考该项目文档实现。 hexo同时部署多个repository同时部署多个repository： 备份作用 国内国外双部署，优化访问网络 部署一个repository时配置如下：1234deploy: type: git repository: git@github.com:mickolechou/xxx.github.io.git branch: master 通过如下方式同时部署多个repository，默认部署到所有repository的master分支。1234567deploy: type: git repo: github: git@github.com:mickolechou/xxx.github.io.git coding: git@git.coding.net:minibox/xxx.git oschina: git@git.oschina.net:minichou/xxx.git branch: master 也是在每个repository后单独指定部署分支，如下：123456deploy: type: git repo: github: git@github.com:mickolechou/xxx.github.io.git,master coding: git@git.coding.net:minibox/xxx.git,master oschina: git@git.oschina.net:minichou/xxx.git,master hexo添加代码一键复制功能最近使用hexo写博客时发现，有个功能很常用单hexo没提供，那就是代码一键复制功能。想着没有就自己简单实现一个呗，然后就开始各种查资料，果然让我找到了：clipboard.js clipboard.js:复制文本到剪切板不再那么复杂，也不需要繁琐的配置或者加载臃肿的插件；最重要的，不再依赖Flash或者庞大的组件。 使用也很简单，首先js引入：1&lt;script src=\"dist/clipboard.min.js\"&gt;&lt;/script&gt; 简单示例：1234567&lt;!-- Target --&gt;&lt;input id=\"foo\" value=\"https://github.com/zenorocha/clipboard.js.git\"&gt;&lt;!-- Trigger --&gt;&lt;button class=\"btn\" data-clipboard-target=\"#foo\"&gt; &lt;img src=\"images/clippy.svg\" alt=\"Copy to clipboard\"&gt;&lt;/button&gt; 以上示例可实现点击button达到一键复制input中的内容。 Trigger ：触发器即点击该button Target ：目标即所需复制的内容所在元素 接下来我将演示下我是如何通过clipboard.js在我的hexo中添加一键复制功能的。基本思路： 首先在每个代码块中动态增加一个触发器button用于实现点击复制按钮 使用clipboard.js高级用法绑定触发器对应的目标元素 添加事件完成（成功或失败之后的操作）一主要代码：在主题的source\\js\\目录下创建：copycode.js文件123456789101112131415161718192021222324252627282930313233343536(function ($) &#123; $('.highlight').each(function (i, entry) &#123; $(entry).prepend('&lt;button class=\"copy-button invisible\" data-clipboard-snippet&gt;&lt;i class=\"fa fa-copy\"&gt;&lt;/i&gt;&lt;/button&gt;'); &#125;); var clipboardSnippets = new Clipboard('[data-clipboard-snippet]', &#123; target: function (trigger) &#123; return trigger.nextElementSibling.querySelector('.code'); &#125; &#125;); clipboardSnippets.on('success', function (e) &#123; e.clearSelection(); showTooltip(e.trigger, 'check'); &#125;); clipboardSnippets.on('error', function (e) &#123; showTooltip(e.trigger, 'close'); &#125;); $(document).on('mouseleave', '.highlight', function (e) &#123; $(this).find('button').addClass('invisible'); &#125;).on('mouseenter', '.highlight', function (e) &#123; $(this).find('button').removeClass('invisible'); &#125;); function showTooltip(elem, msg) &#123; elem.firstChild.setAttribute('class', 'fa fa-' + msg); window.setTimeout(function () &#123; elem.firstChild.setAttribute('class', 'fa fa-copy'); &#125;, 2000); &#125;&#125;)(jQuery); 然后引入在脚本即可，具体使用参考clipboard.js文档。 参考 百度分享集成 百度分享不支持Https的解决方案 163music-APlayer-you-get clipboardjs","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://minibox.coding.me/categories/杂谈/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://minibox.coding.me/tags/hexo/"}]},{"title":"Java7新特性：try-with-resources自动关闭资源","slug":"Java7新特性：try-with-resources自动关闭资源","date":"2016-04-21T08:42:46.000Z","updated":"2017-04-24T02:27:59.438Z","comments":true,"path":"2016/04/21/Java7新特性：try-with-resources自动关闭资源/","link":"","permalink":"https://minibox.coding.me/2016/04/21/Java7新特性：try-with-resources自动关闭资源/","excerpt":"try-with-resources是Java7中新增特性，它允许在try关键字后跟一对圆括号，括号内可初始化一个或多个资源，try语句会在代码块执行完后自动关闭资源。","text":"try-with-resources是Java7中新增特性，它允许在try关键字后跟一对圆括号，括号内可初始化一个或多个资源，try语句会在代码块执行完后自动关闭资源。 try-with-resources概念在Java7之前，某些稀缺资源（如数据库连接、网络连接，IO流）使用后必须在finally语句中手动关闭，否则可能造成资源泄露、浪费，资源使用一般流程如下形式： 1234567try &#123; //资源使用&#125; catch(Exception e) &#123; //异常处理&#125; finally &#123; //关闭资源&#125; 为解决以上问题，Java7中新增try-with-resources特性。它允许在try关键字后跟一对圆括号，括号内可初始化一个或多个资源，try语句会在代码块执行完后自动关闭资源。资源使用流程如下：12345try (Resource res = ) &#123; //使用资源&#125; catch (Exception e) &#123; //异常处理&#125; try-with-resources特性会在try代码块执行完后自动关闭所有资源，无需在finally中显示调用close()方法手动关闭，一来简洁了代码，二来以免忘记关闭。try-with-resource也可以有catch和finally块，只是执行时机是在try-with-resource之后。 为保证try能正常自动关闭资源，要求资源： 被关闭资源类必须实现autoClosable接口或者是Closable接口 需要自动关闭的资源必须在try后面圆括号内声明 资源自动关闭顺序与声明顺序相反 示例代码使用实例： 1234567891011121314151617181920212223242526272829303132333435363738public class AutoCloseTest &#123; @Test public void testTryWithResource() &#123; try(Resource1 re1 = new Resource1(); Resource2 re2 = new Resource2()) &#123; re1.doThing(); re2.doThing(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; class Resource1 implements AutoCloseable &#123; public void doThing() &#123; System.out.println(\"resource1 do something\"); &#125; @Override public void close() throws Exception &#123; System.out.println(\"close resource1\"); &#125; &#125; class Resource2 implements AutoCloseable &#123; public void doThing() &#123; System.out.println(\"resource2 do something\"); &#125; @Override public void close() throws Exception &#123; System.out.println(\"close resource2\"); &#125; &#125;&#125; 执行结果：1234resource1 do somethingresource2 do somethingclose resource2close resource1 可见资源关闭顺序与初始化顺序相反。 异常测试Java7 以前如果try语句块和finally同时都抛出异常则只会抛出 finally 块中的异常，不会抛出try块中异常。这样经常会导致得到的异常信息不是调用程序想要得到的。 Java7 及以后版本中如果采用try-with-resource机制，如果在try-with-resource 声明中抛出异（可能是文件无法打或都文件无法关闭），同事try语句块中也抛出异常，则首先抛出try块中异常，同时try-with-resource抛出的异常会使用addSuppressed方法，将之前的异常记录下来。我们可以在自己的代码中调用getSuppressed方法去获取异常列表并处理。 采用try-with-resource机制抛异常测试：123456789101112131415161718@Testpublic void testThrowException2() throws Exception &#123; try (Resource3 re3 = new Resource3()) &#123; re3.doThing(); &#125;&#125;class Resource3 implements AutoCloseable &#123; public void doThing() throws Exception &#123; throw new Exception(\"doThing throw exception\"); &#125; @Override public void close() throws Exception &#123; throw new Exception(\"close throw exception\"); &#125;&#125; 执行结果：1234567java.lang.Exception: doThing throw exception at com.zxy.lab.code.test.AutoCloseTest$Resource3.doThing(AutoCloseTest.java:61) at com.zxy.lab.code.test.AutoCloseTest.testThrowException(AutoCloseTest.java:50) ... Suppressed: java.lang.Exception: close throw exception at com.zxy.lab.code.test.AutoCloseTest$Resource3.close(AutoCloseTest.java:66) at com.zxy.lab.code.test.AutoCloseTest.testThrowException(AutoCloseTest.java:52) 从以上异常信息可以看到，对外抛出的异常时try语句块中的异常，同时try-with-resource抛出的异常会使用addSuppressed方法，将之前的异常记录下来。我们可以在自己的代码中调用getSuppressed方法去获取异常列表并处理，所以这才是我们想要的结果。123for (Throwable throwable : e.getSuppressed()) &#123; System.out.println(throwable.getMessage());&#125; Java7之前同时抛出异常测试：1234567891011121314151617181920212223242526@Testpublic void testThrowException3() throws Exception &#123; Resource3 re3 = null; try &#123; re3 = new Resource3(); re3.doThing(); &#125; finally &#123; if (re3 != null) &#123; re3.close(); &#125; &#125;&#125;class Resource3 implements AutoCloseable &#123; public void doThing() throws Exception &#123; throw new Exception(\"doThing throw exception\"); &#125; @Override public void close() throws Exception &#123; throw new Exception(\"close throw exception\"); &#125;&#125; 结果：12345678java.lang.Exception: close throw exception at com.zxy.lab.code.test.AutoCloseTest$Resource3.close(AutoCloseTest.java:106) at com.zxy.lab.code.test.AutoCloseTest.testThrowException3(AutoCloseTest.java:92) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ... 可见，对外只抛出了finally块中异常，这不是我们想要的。 Closeable和AutoColseable接口Closeable接口是jdk5中添加的，AutoColseable则是jdk7才添加的：1234567891011 * @since 1.5 */public interface Closeable extends AutoCloseable * @since 1.7 */public interface AutoCloseable /** * Closes this resource, relinquishing any underlying resources. * This method is invoked automatically on objects managed by the * &#123;@code try&#125;-with-resources statement. AutoCloseable接口对Java7中新增特性try-with-resources提供了支持，只有实现了AutoCloseable接口的类的对象才可以由带资源的try语句进行管理。这个两个接口都只有一个close()方法。1void close() throws Exception 通过这个方法关闭调用对象，释放可能占用的所有资源。try-with-resources会自动调用该方法关闭资源。 Closeable接口也定义了close()方法。实现了Closeable接口的类的对象可以被关闭。从Java7开始，Closeable扩展了AutoCloseable。因此，在Java7中，所有实现了Closeable接口的类也都实现了AutoCloseable接口。","categories":[{"name":"java","slug":"java","permalink":"https://minibox.coding.me/categories/java/"}],"tags":[{"name":"try-with-resources","slug":"try-with-resources","permalink":"https://minibox.coding.me/tags/try-with-resources/"},{"name":"Closeable","slug":"Closeable","permalink":"https://minibox.coding.me/tags/Closeable/"},{"name":"AutoCloseable","slug":"AutoCloseable","permalink":"https://minibox.coding.me/tags/AutoCloseable/"}]},{"title":"缓存穿透及雪崩之常见解决方案","slug":"缓存穿透及雪崩之常见解决方案","date":"2016-04-20T07:33:49.000Z","updated":"2017-04-17T02:08:21.491Z","comments":true,"path":"2016/04/20/缓存穿透及雪崩之常见解决方案/","link":"","permalink":"https://minibox.coding.me/2016/04/20/缓存穿透及雪崩之常见解决方案/","excerpt":"缓存作为应对高并发大流量的神兵利器，如果使用不当，可能会给系统造成致命一击。 缓存穿透什么叫缓存穿透缓存穿透：简而言之就是查询缓存系统和后端系统都不存在的数据。如果这类查询并发量很大，将会对后端存储系统造成很大压力。","text":"缓存作为应对高并发大流量的神兵利器，如果使用不当，可能会给系统造成致命一击。 缓存穿透什么叫缓存穿透缓存穿透：简而言之就是查询缓存系统和后端系统都不存在的数据。如果这类查询并发量很大，将会对后端存储系统造成很大压力。 如何避免缓存穿透造成缓存穿透根本原因：空查询。前端系统不知道所查数据到底存不存在，导致不必要查询。造成空查询的原因主要有两个： 代码设计或数据出现问题 恶意攻击 如何解决空查询呢？避免查库有两个条件： 缓存命中，则不需要查库 事先知道库中不存在，则不需要查库 解决方案针对第一个条件 缓存空值 如果查询数据库不存在，我们之前的操作就不会进行缓存，这里我们仍然缓存空对象。之后再访问这个数据将会从缓存中获取，保护了后端数据源。缓存空对象会有两个问题： 空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。 缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5 分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。 注意：采用缓存空值策略，只能避免第二次空查询，第一次还是会进行查库操作。 针对第二个条件 bloom filter（布隆过滤器） 根据存储层数据构建布隆过滤器，在进行查询操作之前先通过bloom filter判断是否存在，如果存在则继续查询操作，不存在，则直接返回，避免空查询。采用布隆过滤器可能会存在以下问题： 占用部分内存空间，因为要将数据库中的数据全量构造出一个bitmap 存在误判的情况，比如某个key对应的数据其实不存在，但通过bloomfilter判断结果可能存在，这时只需进行一次查库操作，毕竟这种误判率比较低。 无法删除：即使数据库中删除该数据，也无法将其从bloomfilter中删除，只能重新构建。 使用场景：缓存命中率不高，如下场景： 电商客户咨询场景：系统查询最近咨询客服分配给改客户，如无，则随机分配，且这里客户-&gt;最近咨询客服对应信息只存储7天。这类场景缓存命中率不高。 电商商品推荐场景：针对老用户，系统根据用户购买记录进行商品推荐，新用户则没有。用户登录网站系统查询是否存在推荐数据场景，命中率不高。 缓存雪崩什么叫缓存雪崩缓存雪崩: 简而言之就是缓存不可用或失效，导致所有的查询操作都落到后端存储系统，对后端存储系统造成很大压力，严重时可能会冲垮存储系统，产生连锁反应，最终导致服务不可用。 如何防止雪崩发生要避免缓存雪崩，首先要清楚雪崩产生的根本原因：所有缓存在同一个时间段同时失效或不可用，导致同一时间所有查询操作都落到存储层。避免过多查库请求有两个条件： 不要让缓存在同一时间段失效即始终有部分缓存可能 控制查库请求，只允许少量查库操作 解决方案针对以上两个条件在业务代码层面可采取以下策略： 针对不同key设置不同失效时间，尽量将失效时间打散，不要聚集在一个时间段 采取二级缓存策略：同一个数据，缓存两次，分别设置不同的失效时间，这样即使其中一个缓存失效，另一个仍然可用，注意：数据更新时要同时处理两个缓存。 采用加锁或队列控制查库线程数。在缓存失效后，控制真正查库线程数。让一部分线程去查库，获取之后，存入缓存，后续查询直接从缓存获取。 缓存预加载。在系统提供服务之前进行热点key缓存预加载，不至于系统启动之初，由于缓存还没存放，导致所有请求达到后端系统。 缓存永不过期即不设置过期时间：不建议使用，1.造成数据不一致，2.浪费存储空间，可能会造成内存溢出。 在缓存系统架构层面，则尽量采用集群多副本方式保证缓存服务高可用，如redis可采用Redis Sentinel或者Redis Cluster保证缓存服务高可用。 案例分析先给出通用的数据获取方式：123456789101112131415161718192021222324252627282930313233343536373839404142@Testpublic void testGetData() &#123; String id = \"3\"; String data = getData(id); LOGGER.info(\"get data:&#123;&#125;\", data);&#125;/** * 获取数据：先缓存再DB * @param id * @return */private String getData(String id) &#123; String key = KEY_PREFIX + id;; String value = cacheUtil.getString(key); if (StringUtils.isEmpty(value))&#123; value = getFromDB(id); if (value != null) &#123; cacheUtil.setString(key, value); &#125; LOGGER.info(\"get from DB:&#123;&#125;\", value); &#125; else &#123; LOGGER.info(\"get from cache:&#123;&#125;\", value); &#125; return value;&#125;/** * 模拟从DB获取 * @param id * @return */private String getFromDB(String id) &#123; try &#123; Thread.sleep(2000L); return mockDB.get(id); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return null;&#125; 一般我们获取数据，先查缓存，有责返回，无，则查库，再存缓存，返回。以上getData方法就是一种非常普遍的写法，但有没问题呢？举个例子：假如该查库操作比较耗时，需全表扫描，耗时2s,同时数据库最大连接数200,该系统平时并发量1000，假如某时刻缓存失效，此时，所有请求落到数据库。将达到1000*2的并发。 以上情况如果没有进行限制数据库连接，很有可能导致数据库挂掉。 那怎么怎么限制数据库连接数呢，加锁，互斥访问。如下方式：12345678910111213141516171819/** * 获取数据：先缓存再DB * @param id * @return */private synchronized String getData(String id) &#123; String key = KEY_PREFIX + id;; String value = cacheUtil.getString(key); if (StringUtils.isEmpty(value))&#123; value = getFromDB(id); if (value != null) &#123; cacheUtil.setString(key, value); &#125; LOGGER.info(\"get from DB:&#123;&#125;\", value); &#125; else &#123; LOGGER.info(\"get from cache:&#123;&#125;\", value); &#125; return value;&#125; 给getData方法加上synchronized 关键字。以上方式确实可以限制数据库连接数，防止雪崩，但还是存在问题。synchronized关键字的加入，导致所有线程同步访问该访问，就算查缓存也要互斥访问，大大降低了系统响应速度，不可取。 这是我们可能会想，那将锁粒度细化，采用如下方式加锁：12345678910111213141516171819202122/** * 获取数据：先缓存再DB * @param id * @return */private String getData(String id) &#123; String key = KEY_PREFIX + id;; String value = cacheUtil.getString(key); if (StringUtils.isEmpty(value))&#123; synchronized (this)&#123; value = getFromDB(id); if (value != null) &#123; cacheUtil.setString(key, value); &#125; LOGGER.info(\"get from DB:&#123;&#125;\", value); &#125; &#125; else &#123; LOGGER.info(\"get from cache:&#123;&#125;\", value); &#125; return value;&#125; 是不是ok了呢？其实不然，synchronized (this)虽然控制了数据库连接的并发数，但是没有减少连接数，因为所有的查询线程都会发现缓存失效，然后跑到if中，等待查库。那如何解决呢，很简单：double check。123456789101112131415161718192021222324252627282930/** * 获取数据：先缓存再DB * @param id * @return */private String getData(String id) &#123; String key = KEY_PREFIX + id;; String value = cacheUtil.getString(key); if (StringUtils.isEmpty(value))&#123; synchronized (this)&#123; //double check value = cacheUtil.getString(key); if (!StringUtils.isEmpty(value)) &#123; LOGGER.info(\"get from cache:&#123;&#125;\", value); return value; &#125; value = getFromDB(id); if (value != null) &#123; cacheUtil.setString(key, value); &#125; LOGGER.info(\"get from DB:&#123;&#125;\", value); &#125; &#125; else &#123; LOGGER.info(\"get from cache:&#123;&#125;\", value); &#125; return value;&#125; 以上还算比较好的解决了缓存雪崩问题，但是在分布式多实例的情况下，可能会出现重复更新缓存问题。 其实，针对最后一种方式，我们可以进行方法重构，getDate方法中，除了查库这条语句不太相同之外，其他代码都一样。所以，可以参考google guava cache加载策略，当缓存不存在时，调用cacheloader进行数据加载。重构之后的代码如下：1234567891011121314151617181920212223public &lt;T&gt; T getFromCache(String key, long expire, Class&lt;T&gt; tClass, CacheLoader&lt;T&gt; loader) &#123; T value = cacheUtil.get(key, tClass); if (StringUtils.isEmpty(value)) &#123; synchronized (this) &#123; //double check value = cacheUtil.get(key, tClass); if (!StringUtils.isEmpty(value)) &#123; LOGGER.info(\"get from cache:&#123;&#125;\", value); return value; &#125; value = loader.load(); if (value != null) &#123; cacheUtil.setWithExp(key, value, expire); &#125; LOGGER.info(\"get from DB:&#123;&#125;\", value); &#125; &#125; else &#123; LOGGER.info(\"get from cache:&#123;&#125;\", value); &#125; return value;&#125; 这里定义了一个CacheLoader接口，该接口内只包含一个load抽象方法，待子类具体实现。12345public interface CacheLoader&lt;T&gt; &#123; T load();&#125; 以下是测试代码：12345678910public User findUser(final Long id) &#123; String key = KEY_PREFIX + id; User user = getFromCache(key, 3600L, User.class, new CacheLoader&lt;User&gt;() &#123; @Override public User load() &#123; return getUserFromDB(id); &#125; &#125;); return user;&#125; ok，暂时到这。","categories":[{"name":"redis","slug":"redis","permalink":"https://minibox.coding.me/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://minibox.coding.me/tags/redis/"},{"name":"缓存穿透","slug":"缓存穿透","permalink":"https://minibox.coding.me/tags/缓存穿透/"},{"name":"缓存雪崩","slug":"缓存雪崩","permalink":"https://minibox.coding.me/tags/缓存雪崩/"}]},{"title":"Git多ssh-key配置","slug":"Git多ssh-key配置","date":"2016-04-10T06:40:54.000Z","updated":"2017-04-20T01:03:01.019Z","comments":true,"path":"2016/04/10/Git多ssh-key配置/","link":"","permalink":"https://minibox.coding.me/2016/04/10/Git多ssh-key配置/","excerpt":"由于github pages国外网络访问较慢，故准备将blog迁至国内coding pages。又因两网站email不同，导致同一ssh key不同两用，没得法，只能采用多网站多key方式部署。","text":"由于github pages国外网络访问较慢，故准备将blog迁至国内coding pages。又因两网站email不同，导致同一ssh key不同两用，没得法，只能采用多网站多key方式部署。 之所以采用git ssh方式，主要是避免每次push都得输入用户名密码操作。采用https则必须每次输入用户信息。 通过公钥认证可实现ssh免密码登陆，git的ssh方式也是通过公钥进行认证的。 在用户目录的home目录下，有一个.ssh的目录，和当前用户ssh配置认证相关的文件，几乎都在这个目录下。 ssh-keygenssh-keygen可用来生成ssh公钥认证所需的公私钥。 使用 ssh-keygen 时，请先进入到 ~/.ssh 目录，不存在的话，请先创建。并且保证 ~/.ssh 以及所有父目录的权限不能大于 711 生成的文件名和文件位置 使用 ssh-kengen 默认会在~/.ssh/目录(第一次使用ssh前应该是不存在的)下生成两个文件，不指定文件名和密钥类型的时候，默认生成的两个文件是：12id_rsaid_rsa.pub 第一个是私钥文件，第二个是公钥文件。 生成的公私钥文件名 生成ssh key的时候，可以通过 -f 选项指定生成文件的文件名，如下:123$ ssh-keygen -C &quot;test key&quot; -f github``` 如果没有指定文件名，会询问你输入文件名: $ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/home/huqiu/.ssh/id_rsa):123456789101112你可以输入你想要的文件名，这里我们输入test。3. 私钥使用的密码生成公私钥的时候询问你是否需要输入密码。输入密码之后，以后每次都要输入密码，而且就算别人等到的私钥，没有密码的话也是无法使用私钥解密的。请根据你的安全需要决定是否需要密码，如果不需要，直接回车即可。## 生成SSH多公私钥对1. 首先根据coding.net的注册邮箱生成密钥对如下命令：``` bash$ ssh-keygen -t rsa -C &quot;myemail@coding.net&quot; -f ~/.ssh/id-rsa 以上myemail@coding.net是你在coding.net的邮箱。以上在windows上操作。如果是首次使用ssh，则C:\\Users\\Administrator目录下应该不存在.ssh文件夹。 根据github的注册邮箱生成密钥对。 1234567891011121314151617181920$ ssh-keygen -t rsa -C \"myemail@coding.net\" -f ~/.ssh/githubGenerating public/private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/Administrator/.ssh/github.Your public key has been saved in /c/Users/Administrator/.ssh/github.pub.The key fingerprint is:SHA256:aAcxf3MHgiut+q7Eo9eVPUwLldZl7fJG8rGKAF6MW6I myemail@coding.netThe key's randomart image is:+---[RSA 2048]----+| oo .+..+. || + +=+ ooo.. || o *ooo.o=.+. || E o oBoo o*.. || ++S. o . || . ..o... || +.. || . +.o || o o+o |+----[SHA256]-----+ 以上操作执行完后，~/.ssh目录结构：12$ lsgithub github.pub id_rsa id_rsa.pub 修改配置文件在 ~/.ssh 目录下新建一个config文件（如果没有的话）1touch config 在新建的config中指定coding和github所使用的密钥对。采用如下语法添加：12Host coding.netIdentityFile ~/.ssh/id_rsa Host指定站点IdentityFile指定所使用的密钥对比如我们这位coding.net和github.com指定密钥对则config中添加如下内容：1234Host coding.netIdentityFile ~/.ssh/id_rsaHost github.comIdentityFile ~/.ssh/github 添加公钥到各站点将之前生成的公钥分别添加到各站点比如为coding添加公钥如下： 测试SSH配置是否正常访问以上操作完成后，可通过如下命令测试能否SSH免密连接1ssh -T git@github.com 以上测试连接github,也是自行测试coding.net。如果输出如下内容则表示成功：1Hi stefzhlg! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 注意：首次连接会提示是否确认通过ssh连接，按要求输入yes即可。","categories":[{"name":"git","slug":"git","permalink":"https://minibox.coding.me/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://minibox.coding.me/tags/git/"}]},{"title":"如何避免代码多层嵌套","slug":"如何避免代码多层嵌套","date":"2016-03-31T02:29:55.000Z","updated":"2017-04-17T02:08:21.490Z","comments":true,"path":"2016/03/31/如何避免代码多层嵌套/","link":"","permalink":"https://minibox.coding.me/2016/03/31/如何避免代码多层嵌套/","excerpt":"平时写代码过程中，过多if判断语句的存在导致代码产生多层嵌套，影响代码可读性。","text":"平时写代码过程中，过多if判断语句的存在导致代码产生多层嵌套，影响代码可读性。 if作用代码中if主要用于控制代码流程： 参数合法性校验 业务流程走向 if用于参数合法性校验当if用于参数合法性校验时，避免多层嵌套，可采用以下方式： 使用break,continue有些人写代码，习惯通过if(condition){}判真的方式控制流程走向，这种方式会造成代码多层嵌套。如果我们反过来，采用if(!condition){return; break; continue}判假的方式提前退出嵌套则可减少代码嵌套。进入方法，参数不合法，提前return；进入循环，不满足则break退出循环或continue进行快速进入下一次循环。 使用异常一般情况下，我们使用if主要是为了参数校验，一次又一次的if判断，导致多层嵌套的出现，但又不能不做，很是尴尬。 这种情况，可考虑使用异常统一捕获，try代码块中不做参数校验，所有NPE异常交由外层catch。当然，使用try..catch，一旦异常触发，可能会降低程序的性能；如果做参数检验仅仅是为了避免极端情况的崩溃，在大部分情况下不会发生异常，那么可以放心使用。 if用于控制业务流程使用多态比如以下代码：根据type调用不同通知接口给用户发送通知123456789101112131415161718192021private void sendNotify(Integer type, String msg) &#123; if (type == 1) &#123; sendEmail(msg); &#125; else if (type == 2)&#123; sendMsg(msg); &#125; else if (type == 3)&#123; sendWechat(msg); &#125;&#125;private void sendWechat(String msg) &#123; System.out.println(\"wechat\" + msg);&#125;private void sendMsg(String msg) &#123; System.out.println(\"message\" + msg);&#125;private void sendEmail(String msg) &#123; System.out.println(\"email\" + msg);&#125; 多态解决：抽象出一个基类1234567891011public abstract class SendNotify &#123; public void send(String msg) &#123; System.out.println(\"start send\"); doSend(msg); System.out.println(\"end send\"); &#125; public abstract void doSend(String msg);&#125; 子类继承父类，同时自己实现具体的发送通知操作12345678910111213141516171819202122public class SendEmial extends SendNotify &#123; @Override public void doSend(String msg) &#123; System.out.println(\"email\" + msg); &#125;&#125;public class SendMsg extends SendNotify &#123; @Override public void doSend(String msg) &#123; System.out.println(\"message\" + msg); &#125;&#125;public class SendWechat extends SendNotify &#123; @Override public void doSend(String msg) &#123; System.out.println(\"wechat\" + msg); &#125;&#125; 测试：1234567891011public void testSendNotify() &#123; //采用双括号初始化赋值 Map&lt;Integer, SendNotify&gt; sendNotifyMap = new HashMap() &#123;&#123; put(1, new SendEmial()); put(2, new SendMsg()); put(3, new SendWechat()); &#125;&#125; ; SendNotify sendNotify = sendNotifyMap.get(2); sendNotify.send(\"hello\");&#125; 使用枚举12345678910111213141516171819202122232425262728public enum NotifyEnum &#123; Emial(1, SendEmial.class), Msg(2, SendMsg.class), Wechat(3, SendWechat.class); private Integer type; private Class clazz; NotifyEnum(int type, Class clazz) &#123; this.type = type; this.clazz = clazz; &#125; public static NotifyEnum find(int type) &#123; for (NotifyEnum notify : values()) &#123; if (notify.type == type) &#123; return notify; &#125; &#125; return null; &#125; public Integer getType() &#123; return type; &#125; public Class getClazz() &#123; return clazz; &#125;&#125; 测试： 12345public void testEnumSendNotify() throws IllegalAccessException, InstantiationException &#123; NotifyEnum notifyEnum = NotifyEnum.find(3); SendNotify notify = (SendNotify)notifyEnum.getClazz().newInstance(); notify.send(\"world\");&#125; 使用map通过K-V的方式存入map，调用时不用if判断，跟枚举类似。 123456789public void testSendNotify() &#123; Map&lt;Integer, SendNotify&gt; sendNotifyMap = new HashMap() ; sendNotifyMap.put(1, new SendEmial()); sendNotifyMap.put(2, new SendMsg()); sendNotifyMap.put(3, new SendWechat()); SendNotify sendNotify = sendNotifyMap.get(2); sendNotify.send(\"hello\");&#125; 抽取方法通过抽取方法可将多层多层嵌套分配到各个方法中去，减少主方法的嵌套层数，提高可读性。 参考编写优美的代码之减少嵌套","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://minibox.coding.me/categories/杂谈/"}],"tags":[]},{"title":"Redis Sentinel原理","slug":"Redis Sentinel原理","date":"2016-03-25T09:49:28.000Z","updated":"2017-04-17T02:08:21.485Z","comments":true,"path":"2016/03/25/Redis Sentinel原理/","link":"","permalink":"https://minibox.coding.me/2016/03/25/Redis Sentinel原理/","excerpt":"本文将主要分析redis sentinel模式中sentinel（哨兵）所起作用 Sentinel主要功能sentinel主要功能是在主库（master）出现问题后，实现：master存活检测、主从运行情况检测、自动failover、主从切换等高可用。redis的sentinel最小配置是一主一从，实现故障转移高可用。","text":"本文将主要分析redis sentinel模式中sentinel（哨兵）所起作用 Sentinel主要功能sentinel主要功能是在主库（master）出现问题后，实现：master存活检测、主从运行情况检测、自动failover、主从切换等高可用。redis的sentinel最小配置是一主一从，实现故障转移高可用。 基本原理：投票算法+心跳机制 在哨兵的运行阶段，其会向其他的哨兵、master和slave发送消息确认其是否存活，如果在指定的时间内未收到正常回应，暂时认为对法挂起了（被标记为主观宕机–SDOWN）当多个哨兵都报告同一个master没有响应了，通过投票算法，系统判断其已死亡（被标记为客观宕机–ODOWN）。在已知的slave节点中，根据实际情况和优先级从该下线的master所属slave中选出一个slave提升为新的master，其他的slave都指向这个新的master，继续维护主从关系。 redis的sentinel系统可以用来管理多个redis服务器，该系统可以执行以下三个任务： 监控：sentinel会不断的检查你的主服务器和从服务器是否正常运行。 提醒：当被监控的某个redis服务器出现问题，sentinel通过API向管理员或者其他的应用程序发送通知。自动故障转移：当主服务器不能正常工作时，sentinel会开始一次自动的故障转移操作，它会将与失效主服务器是主从关系的其中一个从库升级为新的主服务器，并且修改其他的的slave，重定向到新的slave。 redis的sentinel是一个分布式系统，可以在一个架构下运行多个sentinel进程，这些进程之间通过流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从slave服务器作为新的主服务器。 关于redis sentinel的主观下线和客观下线redis sentinel关于被监控的redis实例出现不响应的判断，内部有两种不同的概念：主观下线和客观下线 主观下线：当只有单个sentinel实例对redis实例做出无响应的判断，此时进入主观判断，不会触发自动故障转移等操作。注意，一个服务器必须在 master-down-after-milliseconds 毫秒内， 一直返回无效回复才会被 Sentinel 标记为主观下线。 客观下线：多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线） 从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了流言协议： 如果 Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。 客观下线条件只适用于主服务器： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作。 Sentinel定时执行的操作 每个 Sentinel 以每秒钟一次的频率向它所知的主服务器、从服务器以及其他 Sentinel 实例发送一个 PING 命令。如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 那么这个实例会被 Sentinel 标记为主观下线。 一个有效回复可以是： +PONG 、 -LOADING 或者 -MASTERDOWN 。 如果一个主服务器被标记为主观下线， 那么正在监视这个主服务器的所有 Sentinel 要以每秒一次的频率确认主服务器的确进入了主观下线状态。 如果一个主服务器被标记为主观下线， 并且有足够数量的 Sentinel （至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。 在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。 当一个主服务器被 Sentinel 标记为客观下线时， Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。 当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主管下线状态就会被移除。 自动发现哨兵（sentinel）和从服务器sentinel与sentinel之间可以进行信息交换和检测对方的可用性。 无需为运行的每个sentinel分别设置其他的sentinel地址，因为sentinel可以通过redis内部的发布\\订阅功能来自动的发现正在监视相同主机服务器的其他sentinel，这个功能是通过 sentinel:hello发送消息来实现的。 不必列出所有slave的信息，因为sentinel可以通过询问主服务器获取从服务器信息。 每个 Sentinel 会以每两秒一次的频率， 通过发布与订阅功能， 向被它监视的所有主服务器和从服务器的 sentinel:hello 频道发送一条信息， 信息中包含了 Sentinel 的 IP 地址、端口号和运行 ID （runid）。 每个 Sentinel 都订阅了被它监视的所有主服务器和从服务器的 sentinel:hello 频道， 查找之前未出现过的 sentinel （looking for unknown sentinels）。 当一个 Sentinel 发现一个新的 Sentinel 时， 它会将新的 Sentinel 添加到一个列表中， 这个列表保存了 Sentinel 已知的， 监视同一个主服务器的所有其他 Sentinel 。 Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。 在将一个新 Sentinel 添加到监视主服务器的列表上面之前， Sentinel 会先检查列表中是否已经包含了和要添加的 Sentinel 拥有相同运行 ID 或者相同地址（包括 IP 地址和端口号）的 Sentinel ， 如果是的话， Sentinel 会先移除列表中已有的那些拥有相同运行 ID 或者相同地址的 Sentinel ， 然后再添加新 Sentinel Sentinel执行failover流程 sentinel发现master下线，修改其状态为sdown； sentinel和其他sentinel确认master是否down掉，确认其状态为odown； 对我们的当前纪元进行自增（详情请参考 Raft leader election ）， 并尝试在这个纪元中当选(即首先发现master down掉的sentinel有优先权当选为leader)； 如果当选失败，那么在设定的故障迁移超时时间的两倍之后，重新尝试当选。如果当选成功，那么执行以下步骤； 选出一个从服务器，并将它升级为主服务器； leader选出一个slave作为master，发送slaveof no one命令； 通过发布与订阅功能，将更新后的配置传播给所有其他 Sentinel，其他 Sentinel 对它们自己的配置进行更新； 并通过给其他slave发送slaveof master命令告知其他slave新的master； 当所有从服务器都已经开始复制新的主服务器时，领头Sentinel终止这次故障迁移操作。 Sentinel发出投票通知发现一个master down掉的sentinel发出投票请求的时候，接收者依据epoch进行判断后并返回它认为的leader后，发现者对接收者的意见照单全收，并没有进行“反驳”。换句话说，接收者接收所有的接收者的意见后，并没有进行一番比较，就接收了每个接收者的认为的leader，结果其leader就是最后一个接收者认为的leader。 但是从另一方面说，每个接收者都会收到所有潜在的leader的选举邀请，他们会对所有这些候选者进行比较一番后，本地的leader肯定是最后比较的结果，这个结果会通过反馈给每个候选者的通知，使他们知道最终的胜出者，所以还是能选举出最后的leader。 Sentinel领头羊选举Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。 这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。 更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。 简单来说， 我们可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。 举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。 如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。 Sentinel主master选举Sentinel 使用以下规则来选择新的主服务器： 在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。 在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。 Sentinel与redis实例之间的通信以下是sentinel节点所接受的命令： PING ：返回 PONG 。 SENTINEL masters ：列出所有被监视的主服务器，以及这些主服务器的当前状态。 SENTINEL slaves ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。 SENTINEL get-master-addr-by-name ： 返回给定名字的主服务器的 IP 地址和端口号。 如果这个主服务器正在执行故障转移操作， 或者针对这个主服务器的故障转移操作已经完成， 那么这个命令返回新的主服务器的 IP 地址和端口号。 SENTINEL reset ： 重置所有名字和给定模式 pattern 相匹配的主服务器。 pattern 参数是一个 Glob 风格的模式。 重置操作清除主服务器目前的所有状态， 包括正在执行中的故障转移， 并移除目前已经发现和关联的， 主服务器的所有从服务器和 Sentinel 。 SENTINEL failover ： 当主服务器失效时， 在不询问其他 Sentinel 意见的情况下， 强制开始一次自动故障迁移 （不过发起故障转移的 Sentinel 会向其他 Sentinel 发送一个新的配置，其他 Sentinel 会根据这个配置进行相应的更新）。 sentinel连接一个redis实例的时候，会创建cmd和pub/sub两个链接，cmd连接创建成功时候立即发送一个ping命令，pub/sub连接创建成功的时候立即去监听hello channel。通过cmd连接给redis发送命令，通过pub/sub连接得到redis实例上的其他sentinel实例。sentinel与maste/slave的交互主要包括： PING:sentinel向其发送PING以了解其状态（是否下线） INFO:sentinel向其发送INFO以获取replication相关的信息，通过这个命令可以获取master的slaves PUBLISH:sentinel向其监控的master/slave发布本身的信息及master相关的配置 SUBSCRIBE:sentinel通过订阅master/slave的”sentinel:hello“频道以获取其它正在监控相同服务的sentinels sentinel与sentinel的交互主要包括： PING:sentinel向slave发送PING以了解其状态（是否下线） SENTINEL is-master-down-by-addr：和其他sentinel协商master状态，如果master odown，则投票选出leader做fail over Sentinel配置文件参数说明部分参数说明：port ：sentinel实例之间通讯的端口 dir :指定工作目录 sentinel monitor：sentinel需要监控的主库信息 sentinel monitor其中master-name为自定义master名称，ip为master所在主机的ip地址，redis-port为redis实例的端口号，quorum界定有多少个sentinel实例提交与master通信失败才会判断master为客观宕机（ODOWN），从而发起自动切换。 sentinel auth-pass：如果master开启的密码验证，在这里配置master的密码 sentinel auth-pass sentinel down-after-milliseconds：master被当前sentinel判断为失效的时间间隔，sentinel与master之间的通信没有响应或者代码错误等超过这个时间限定，sentinel会判断master为客观宕机SDOWNdown-after-millisecondssentinel parallel-syncs：当自动切换完成后，同时进行slaveof到新的master并行执行SYNC的slave个数，默认为1，建议线上保留这个数字，在slave执行slaveof的时候，将不会对客户端请求进行响应，对于读写分离业务会有一定的影响sentinel parallel-syncs sentinel failover-timeout：制定failover的过期时间，超过此时间没有触发任何的failover操作，当前的sentinel会认为此次的failover擦走哦失败。 sentinel failover-timeout sentinel notification-script ：当进行failover时，可以指定一个通知脚本用来通知系统管理员，当前集群的情况。脚本被允许执行的最大时间为60秒，超过这个时间，脚本会被kill。 sentinel notification-script 稍后重试，最大重试次数为10; 执行结束，无需重试 sentinel client-reconfig-script：failover之后重配置客户端，执行脚本时会传递大量参数，请参考相关文档","categories":[{"name":"redis","slug":"redis","permalink":"https://minibox.coding.me/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://minibox.coding.me/tags/redis/"},{"name":"sentinel原理","slug":"sentinel原理","permalink":"https://minibox.coding.me/tags/sentinel原理/"}]},{"title":"Redis Sentinel高可用集群搭建及Spring集成","slug":"Redis Sentinel高可用集群搭建及Spring集成","date":"2016-03-23T09:42:36.000Z","updated":"2017-04-17T02:08:21.486Z","comments":true,"path":"2016/03/23/Redis Sentinel高可用集群搭建及Spring集成/","link":"","permalink":"https://minibox.coding.me/2016/03/23/Redis Sentinel高可用集群搭建及Spring集成/","excerpt":"本文将介绍如何通过Sentinel实现Redis集群(主从)的高可用方案，该方案需要使用Jedis2.2.2及以上版本（强制），Redis2.8及以上版本(可选，Sentinel最早出现在Redis2.4中，Redis2.8中Sentinel更加稳定)，同时将redis与spring-date-redis集成。 一、Sentinel介绍Sentinel是Redis的高可用性（HA）解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器故障时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。Redis提供的sentinel（哨兵）机制，通过sentinel模式启动redis后，自动监控master/slave的运行状态，基本原理是：心跳机制+投票裁决","text":"本文将介绍如何通过Sentinel实现Redis集群(主从)的高可用方案，该方案需要使用Jedis2.2.2及以上版本（强制），Redis2.8及以上版本(可选，Sentinel最早出现在Redis2.4中，Redis2.8中Sentinel更加稳定)，同时将redis与spring-date-redis集成。 一、Sentinel介绍Sentinel是Redis的高可用性（HA）解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器故障时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。Redis提供的sentinel（哨兵）机制，通过sentinel模式启动redis后，自动监控master/slave的运行状态，基本原理是：心跳机制+投票裁决 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器选举出来，升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。 二、Sentinel的主从原理以下为Sentinel架构以及主从切换图： Jedis2.2.2之前版本，因为主从实例地址(IP PORT)是不同的，当故障发生进行主从切换后，应用程序无法知道新地址，故在Jedis2.2.2中新增了对Sentinel的支持，应用通过redis.clients.jedis.JedisSentinelPool.getResource()取得的Jedis实例会及时更新到新的主实例地址。 三、Redis Sentinel高可用集群搭建首先稍微介绍下如何在linux上安装redis redis安装1234$ wget http://download.redis.io/releases/redis-3.2.8.tar.gz$ tar xzf redis-3.2.8.tar.gz$ cd redis-3.2.8$ make 测试：首先启动redis服务1fish@test-vm:~/server/redis-3.2.8$ src/redis-server 然后打开一个新的命令窗口，启动redis client端进行测试。12345fish@test-vm:~/server/redis-3.2.8$ src/redis-cli 127.0.0.1:6379&gt; set name fishOK127.0.0.1:6379&gt; get name\"fish\" redis sentinel集群搭建硬件条件有限，这里我将采用伪分布式进行搭建，所有节点都在同一台虚拟机，通过不同端口区分：2个哨兵，1个主redis，2个从redis首先在redis目录创建conf目录，然后在其中添加一下配置文件，配置文件如下： 123456fish@test-vm:~/server/redis-3.2.8/conf$ ls -1redis-master-6379.confredis-slave-6380.confredis-slave-6381.confsentinel-63791.confsentinel-63792.conf redis节点配置可通过复制redis目录下的redis.conf默认配置进行相应修改，sentinel节点的配置文件则可通过复制redis目录下的sentinel.conf配置内容进行相应修改。sentinel_63791.conf 配置：123456789port 63791daemonize yeslogfile \"/var/log/sentinel_63791.log\"#master-1sentinel monitor master-1 192.168.78.99 6379 2sentinel down-after-milliseconds master-1 5000sentinel failover-timeout master-1 18000sentinel auth-pass master-1 yingjunsentinel parallel-syncs master-1 1 sentinel_63792.conf 配置：123456789port 63792daemonize yeslogfile \"/var/log/sentinel_63792.log\"#master-1sentinel monitor master-1 192.168.78.99 6379 2sentinel down-after-milliseconds master-1 5000sentinel failover-timeout master-1 18000sentinel auth-pass master-1 yingjunsentinel parallel-syncs master-1 1 redis_master_6379.conf 配置：在原配置文件中作如下修改：1234port 6379daemonize yesrequirepass yingjunmasterauth yingjun redis_slave_6380.conf 配置：在原配置文件中作如下修改：12345port 6380daemonize yesrequirepass yingjunslaveof 192.168.78.99 6379masterauth yingjun redis_slave_6381.conf 配置：在原配置文件中作如下修改：12345port 6381daemonize yesrequirepass yingjunslaveof 192.168.78.99 6379masterauth yingjun 按如下顺序依次启动服务：12345./redis-server ../conf/redis_master_6379.conf./redis-server ../conf/redis_slave_6381.conf ./redis-server ../conf/redis_slave_6382.conf ./redis-sentinel ../conf/sentinel_63791.conf./redis-sentinel ../conf/sentinel_63792.conf 查看进程是否都已经启动： 1234567fish@test-vm:~$ ps -ef|grep redisfish 30233 2408 0 15:23 ? 00:00:03 src/redis-server *:6379fish 30257 2408 0 15:24 ? 00:00:03 src/redis-server *:6380fish 30270 2408 0 15:24 ? 00:00:03 src/redis-server *:6381fish 30503 2408 0 16:06 ? 00:00:00 src/redis-sentinel *:63791 [sentinel]fish 30514 2408 0 16:06 ? 00:00:00 src/redis-sentinel *:63792 [sentinel]fish 30549 8143 0 16:09 pts/18 00:00:00 grep --color=auto redis 查看master的状态：1234567891011121314151617fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 637910.14.137.85:6379&gt; set name tom(error) NOAUTH Authentication required.10.14.137.85:6379&gt; auth fish@123OK10.14.137.85:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=10.14.137.85,port=6380,state=online,offset=66732,lag=1slave1:ip=10.14.137.85,port=6381,state=online,offset=66732,lag=1master_repl_offset:66871repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:6687010.14.137.85:6379&gt; 可以看到role为master，同时显示了旗下有两个slave通过src/redis-cli -h 10.14.137.85 -p 6379命令登录master客户端，如何redis设置了password，此时可以进入，但是不能进行操作，需通过autho password命令授权后，在可进行其他操作。也可登录时加上-a password参数指定密码。 查看slave的状态：1234567891011121314151617181920212223fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 638010.14.137.85:6380&gt; get name(error) NOAUTH Authentication required.10.14.137.85:6380&gt; auth fish@123OK10.14.137.85:6380&gt; info replication# Replicationrole:slavemaster_host:10.14.137.85master_port:6379master_link_status:upmaster_last_io_seconds_ago:0master_sync_in_progress:0slave_repl_offset:84567slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:010.14.137.85:6380&gt; 可以看到role为slave，只读不能写 查看sentinel的状态：1234fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 6379110.14.137.85:63791&gt; info sentinelDENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command 'CONFIG SET protected-mode no' from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to 'no', and then restarting the server. 3) If you started the server manually just for testing, restart it with the '--protected-mode no' option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.10.14.137.85:63791&gt; 从以上输出可以发现，竟然出错了，仔细查看输出信息，说是redis运行在保护模式protected-mode 是为了禁止公网访问redis cache，加强redis安全的。它启用的条件，有两个： 没有bind IP 没有设置访问密码 如果启用了，则只能够通过lookback ip（127.0.0.1）访问Redis cache，如果从外网访问，则会返回相应的错误信息，就是上图中的信息。因此在新的版本中，应该配置绑定IP和访问密码，这样的话才不会报错误这里master及两台slave redis由于设置了pass，所以不会提示，但sentinel既没设置pass也没绑定ip，所以连接sentinel时出现以上提示，解决方案： 更改配置文件，将protected-mode设置为no 通过命令关闭保护模式：CONFIG SET protected-mode no 重启服务，启动时加上参数：–protected-mode no 绑定ip或设置pass 采取其中一种即可。ok后，查看sentinel状态：12345678910fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 6379110.14.137.85:63791&gt; info sentinel# Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name=master-1,status=ok,address=10.14.137.85:6379,slaves=2,sentinels=210.14.137.85:63791&gt; 接下来验证redis sentinel的主从切换： 首先关闭主redis（6379）服务（shutdown）。查看哨兵，发现端口号为6380的从服务变成了主服务,sentinel自动完成了故障切换。1234567891011fish@test-vm:~/server/redis-3.2.8$ kill -9 31013fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 6379110.14.137.85:63791&gt; info sentinel# Sentinelsentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0sentinel_simulate_failure_flags:0master0:name=master-1,status=ok,address=10.14.137.85:6380,slaves=2,sentinels=210.14.137.85:63791&gt; 可以看到哨兵所监听的master address变成了address=10.14.137.85:6380 启动刚才被shutdown的6379服务并查看，发现它变成了从服务。 12345678910111213141516fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 638010.14.137.85:6380&gt; info replicationNOAUTH Authentication required.10.14.137.85:6380&gt; auth fish@123OK10.14.137.85:6380&gt; info replication# Replicationrole:masterconnected_slaves:1slave0:ip=10.14.137.85,port=6381,state=online,offset=22085,lag=0master_repl_offset:22085repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:2208410.14.137.85:6380&gt; 可见，之前的slave变成了master重新启动之前的master：1234567891011121314151617181920fish@test-vm:~/server/redis-3.2.8$ src/redis-server conf/redis-master-6379.conf fish@test-vm:~/server/redis-3.2.8$ src/redis-cli -h 10.14.137.85 -p 6379 -a fish@12310.14.137.85:6379&gt; info replication# Replicationrole:slavemaster_host:10.14.137.85master_port:6380master_link_status:upmaster_last_io_seconds_ago:1master_sync_in_progress:0slave_repl_offset:46407slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:010.14.137.85:6379&gt; 发现之前的master下线重启之后role变为了slave。 四、Jedis Sentinel教程Maven依赖：1234567891011&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; redis的配置文件：123456789101112#redis configredis.pass=yingjunredis.pool.maxTotal=105redis.pool.maxIdle=10redis.pool.maxWaitMillis=60000redis.pool.testOnBorrow=truesentinel1.ip=192.168.78.99sentinel1.port=63791sentinel2.ip=192.168.78.99sentinel2.port=63792 Spring的配置文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- Redis 配置 --&gt; &lt;!--//jedis 连接池配置--&gt; &lt;bean id=\"jedisPoolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.pool.maxTotal&#125;\"/&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.pool.maxIdle&#125;\"/&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.pool.maxWaitMillis&#125;\"/&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.pool.testOnBorrow&#125;\"/&gt; &lt;/bean&gt; &lt;!--redis sentinel集群 节点信息配置--&gt; &lt;bean id=\"sentinelConfiguration\" class=\"org.springframework.data.redis.connection.RedisSentinelConfiguration\"&gt; &lt;property name=\"master\"&gt; &lt;bean class=\"org.springframework.data.redis.connection.RedisNode\"&gt; &lt;property name=\"name\" value=\"master-1\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=\"sentinels\"&gt; &lt;set&gt; &lt;bean class=\"org.springframework.data.redis.connection.RedisNode\"&gt; &lt;constructor-arg name=\"host\" value=\"$&#123;sentinel1.ip&#125;\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"port\" value=\"$&#123;sentinel1.port&#125;\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.data.redis.connection.RedisNode\"&gt; &lt;constructor-arg name=\"host\" value=\"$&#123;sentinel2.ip&#125;\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"port\" value=\"$&#123;sentinel2.port&#125;\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Jedis ConnectionFactory连接配置 --&gt; &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"password\" value=\"$&#123;redis.pass&#125;\"/&gt; &lt;property name=\"poolConfig\"&gt; &lt;ref bean=\"jedisPoolConfig\"/&gt; &lt;/property&gt; &lt;constructor-arg name=\"sentinelConfig\" ref=\"sentinelConfiguration\"/&gt; &lt;/bean&gt; &lt;!-- redisTemplate配置，redisTemplate是对Jedis的对redis操作的扩展，有更多的操作，封装使操作更便捷 --&gt; &lt;!--通用redisTemplate 指定序列化器--&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"/&gt; &lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; &lt;/property&gt; &lt;property name=\"hashKeySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/&gt; &lt;/property&gt; &lt;!--如果value采用jdk自带序列化处理器，则需要序列号的对象必须实现Serializable--&gt; &lt;property name=\"valueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/&gt; &lt;/property&gt; &lt;property name=\"hashValueSerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--专门处理String类型的key-value--&gt; &lt;bean id=\"stringRedisTemplate\" class=\"org.springframework.data.redis.core.StringRedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 代码中直接用redisTemplate调用：12345678910111213141516@Overridepublic boolean add(final KeyToken tkey) &#123; boolean result = redisTemplate.execute(new RedisCallback&lt;Boolean&gt;() &#123; @Override public Boolean doInRedis(RedisConnection connection) throws DataAccessException &#123; RedisSerializer&lt;String&gt; serializer = getRedisSerializer(); byte[] key = serializer.serialize(tkey.getIndex()); byte[] name = serializer.serialize(tkey.getExpire_time()); return connection.setNX(key, name); &#125; &#125;); return result;&#125; 以下是测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.zxy.lab.code.redis;import com.google.gson.Gson;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataAccessException;import org.springframework.data.redis.connection.RedisConnection;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import java.io.Serializable;import java.util.Date;/** * Created by cdzhouxiaoyu@jd.com on 2017/3/28. */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:spring-config.xml\")public class SentinelRedisTest &#123; @Resource(name = \"stringRedisTemplate\") private StringRedisTemplate stringRedisTemplate; @Autowired private RedisTemplate&lt;String, Object&gt; redisTemplate; @Test public void testPutCache() &#123; String key = \"redis-test\"; ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue(); valueOperations.set(key, \"hello\"); System.out.println(valueOperations.get(key));// hello &#125; @Test public void testPutObject() &#123; String key = \"redis-test-order\"; Order order = new Order(1234L, 100, new Date()); ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue(); valueOperations.set(key, order); System.out.println(valueOperations.get(key));// Order&#123;orderId=1234, price=100.0, submitTime=Tue Mar 28 17:51:56 CST 2017&#125; &#125; @Test public void testPutObjectByStringRedisTemplate() &#123; final String key = \"redis-test-order\"; final Order order = new Order(1234L, 100, new Date()); Boolean result = stringRedisTemplate.execute(new RedisCallback&lt;Boolean&gt;() &#123; @Override public Boolean doInRedis(RedisConnection redisConnection) throws DataAccessException &#123; // 先将对象转换为json字符串，再采用StringSerializer。可知，这里可以自定义序列号方式，比如采用Protostuff序列号对象 RedisSerializer&lt;String&gt; stringSerializer = redisTemplate.getStringSerializer(); byte[] k = stringSerializer.serialize(key); byte[] v = stringSerializer.serialize(new Gson().toJson(order)); return redisConnection.setNX(k, v); &#125; &#125;); Object value = stringRedisTemplate.execute(new RedisCallback&lt;Object&gt;() &#123; @Override public Object doInRedis(RedisConnection redisConnection) throws DataAccessException &#123; RedisSerializer&lt;String&gt; stringSerializer = redisTemplate.getStringSerializer(); byte[] v = redisConnection.get(stringSerializer.serialize(key)); String valueStr = stringSerializer.deserialize(v); return new Gson().fromJson(valueStr, Order.class); &#125; &#125;); System.out.println(value); //Order&#123;orderId=1234, price=100.0, submitTime=Tue Mar 28 18:18:40 CST 2017&#125; &#125; public static class Order implements Serializable&#123; private Long orderId; private double price; private Date submitTime; public Order() &#123; &#125; public Order(Long orderId, double price, Date submitTime) &#123; this.orderId = orderId; this.price = price; this.submitTime = submitTime; &#125; public Long getOrderId() &#123; return orderId; &#125; public void setOrderId(Long orderId) &#123; this.orderId = orderId; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; public Date getSubmitTime() &#123; return submitTime; &#125; public void setSubmitTime(Date submitTime) &#123; this.submitTime = submitTime; &#125; @Override public String toString() &#123; return \"Order&#123;\" + \"orderId=\" + orderId + \", price=\" + price + \", submitTime=\" + submitTime + '&#125;'; &#125; &#125;&#125; 常见问题以下是测试过程中遇到的问题： 测试工程启动时报如下错误： java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter 详细错误信息如下：123456789101112131415161718192021222324Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;redisTemplate&apos; defined in class path resource [spring/spring-redis.xml]: Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.&lt;init&gt;(Ljava/lang/ClassLoader;)V at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1514) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:293) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:223) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:290) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:191) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:638) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:942) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482) at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:120) at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60) at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:102) at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:246) at org.springframework.test.context.CacheAwareContextLoaderDelegate.loadContextInternal(CacheAwareContextLoaderDelegate.java:69) at org.springframework.test.context.CacheAwareContextLoaderDelegate.loadContext(CacheAwareContextLoaderDelegate.java:95) ... 29 moreCaused by: java.lang.NoSuchMethodError: org.springframework.core.serializer.support.DeserializingConverter.&lt;init&gt;(Ljava/lang/ClassLoader;)V at org.springframework.data.redis.serializer.JdkSerializationRedisSerializer.&lt;init&gt;(JdkSerializationRedisSerializer.java:54) at org.springframework.data.redis.core.RedisTemplate.afterPropertiesSet(RedisTemplate.java:122) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1573) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1511) ... 44 more 原因： spring版本过低，spring-data-redis采用了新的构造函数。 解决方案：升级spring版本指4.2.1以上","categories":[{"name":"redis","slug":"redis","permalink":"https://minibox.coding.me/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://minibox.coding.me/tags/redis/"},{"name":"sentinel","slug":"sentinel","permalink":"https://minibox.coding.me/tags/sentinel/"},{"name":"spring-data-redis","slug":"spring-data-redis","permalink":"https://minibox.coding.me/tags/spring-data-redis/"}]},{"title":"面向对象设计原则","slug":"面向对象设计原则","date":"2016-02-24T09:59:51.000Z","updated":"2017-04-24T10:01:53.470Z","comments":true,"path":"2016/02/24/面向对象设计原则/","link":"","permalink":"https://minibox.coding.me/2016/02/24/面向对象设计原则/","excerpt":"面向对象设计原则 如何设计出一个高可维护性、可复用性及可扩展新的软件是面向对象设计需要解决的核心问题之一。","text":"面向对象设计原则 如何设计出一个高可维护性、可复用性及可扩展新的软件是面向对象设计需要解决的核心问题之一。 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一 最常见的7种面向对象设计原则如下表所示：7种常用的面向对象设计原则 设计原则名称 定义 单一职责原则 (Single Responsibility Principle, SRP) 一个类只负责一个功能领域中的相应职 开闭原则 (Open-Closed Principle, OCP) 软件实体应对扩展开放，而对修改关闭 里氏代换原则 (Liskov Substitution Principle, LSP) 所有引用基类对象的地方能够透明地使用其子类的对象 依赖倒转原则 (Dependence Inversion Principle, DIP) 抽象不应该依赖于细节，细节应该依赖于抽象 接口隔离原则 (Interface Segregation Principle, ISP) 使用多个专门的接口，而不使用单一的总接口 合成复用原则 (Composite Reuse Principle, CRP) 尽量使用对象组合，而不是继承来达到复用的目的 迪米特法则 (Law of Demeter, LoD) 一个软件实体应当尽可能少地与其他实体发生相互作用 单一职责原则职责拆分，只做一件事情，实现可复用 单一职责原则是实现高内聚、低耦合的指导方针，是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下： 单一职责原则(Single Responsibility Principle,SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 下面通过一个简单实例来进一步分析单一职责原则： Sunny软件公司开发人员针对某CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案： 在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。 现使用单一职责原则对其进行重构。 在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类： DBUtil：负责连接数据库，包含数据库连接方法getConnection()； CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()； CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。 使用单一职责原则重构后的结构如图2所示： 开闭原则抽象接口，依赖接口，具体操作交给子类实现，实现可扩展 开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由BertrandMeyer于1988年提出，其定义如下： 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示： 在ChartDisplay类的display()方法中存在如下代码片段： 12345678910...... if (type.equals(\"pie\")) &#123; PieChart chart = new PieChart(); chart.display(); &#125; else if (type.equals(\"bar\")) &#123; BarChart chart = new BarChart(); chart.display(); &#125; ...... 在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。 现对该系统进行重构，使之符合开闭原则。 在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。 具体做法如下： 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类； ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。 重构后结构如图2所示： 在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的源代码。 注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。 里氏代换原则子类所有public方法必须在父类中声明，或子类必须实现父类中声明的所有方法，实现所有引用基类（父类）的地方必须能透明地使用其子类的对象 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。 例如有两个类，一个类为BaseClass，另一个是SubClass类，并且SubClass类是BaseClass类的子类，那么一个方法如果可以接受一个BaseClass类型的基类对象base的话，如：method1(base)，那么它必然可以接受一个BaseClass类型的子类对象sub，method1(sub)能够正常运行。反过来的代换不成立，如一个方法method2接受BaseClass类型的子类对象sub为参数：method2(sub)，那么一般而言不可以有method2(base)，除非是重载方法。 里氏代换原则是开闭原则的具体实现手段之。由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在使用里氏代换原则时需要注意如下几个问题： 子类的所有public方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。 在Sunny软件公司开发的CRM系统中，客户(Customer)可以分为VIP客户(VIPCustomer)和普通客户(CommonCustomer)两类，系统需要提供一个发送Email的功能，原始设计方案如图1所示： 在对系统进行进一步分析后发现，无论是普通客户还是VIP客户，发送邮件的过程都是相同的，也就是说两个send()方法中的代码重复，而且在本系统中还将增加新类型的客户。为了让系统具有更好的扩展性，同时减少代码重复，使用里氏代换原则对其进行重构。 在本实例中，可以考虑增加一个新的抽象客户类Customer，而将CommonCustomer和VIPCustomer类作为其子类，邮件发送类EmailSender类针对抽象客户类Customer编程，根据里氏代换原则，能够接受基类对象的地方必然能够接受子类对象，因此将EmailSender中的send()方法的参数类型改为Customer，如果需要增加新类型的客户，只需将其作为Customer类的子类即可。重构后的结构如图2所示： 里氏代换原则是实现开闭原则的重要方式之一。在本实例中，在传递参数时使用基类对象，除此以外，在定义成员变量、定义局部变量、确定方法返回类型时都可使用里氏代换原则。针对基类编程，在程序运行时再确定具体子类。 依赖倒转原则如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现，依赖倒转原则定义如下： 依赖倒转原则(Dependency Inversion Principle,DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 下面通过一个简单实例来加深对依赖倒转原则的理解： Sunny软件公司开发人员在开发某CRM系统时发现：该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类中将调用数据格式转换类的方法实现格式转换和数据库插入操作，初始设计方案结构如图1所示： 在编码实现图1所示结构时，Sunny软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要更换数据转换类，如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违反了开闭原则，现需要对该方案进行重构。 在本实例中，由于CustomerDAO针对具体数据转换类编程，因此在增加新的数据转换类或者更换数据转换类时都不得不修改CustomerDAO的源代码。我们可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会出现任何问题。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图2所示： 在上述重构过程中，我们使用了开闭原则、里氏代换原则和依赖倒转原则，在大多数情况下，这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 接口隔离原则接口隔离原则定义如下： 接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同： (1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。 (2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 下面通过一个简单实例来加深对接口隔离原则的理解： Sunny软件公司开发人员针对某CRM系统的客户数据显示模块设计了如图1所示接口，其中方法dataRead()用于从文件中读取数据，方法transformToXML()用于将数据转换成XML格式，方法createChart()用于创建图表，方法displayChart()用于显示图表，方法createReport()用于创建文字报表，方法displayReport()用于显示文字报表。 在实际使用过程中发现该接口很不灵活，例如如果一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序编译时将报错。 现使用接口隔离原则对其进行重构。 在图1中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法即可。 通过使用接口隔离原则，本实例重构后的结构如图2所示： 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。 合成复用原则合成复用原则又称为组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP)，其定义如下： 合成复用原则(Composite Reuse Principle, CRP)：尽量使用对象组合，而不是继承来达到复用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 一般而言，如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。 下面通过一个简单实例来加深对合成复用原则的理解： Sunny软件公司开发人员在初期的CRM系统设计中，考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如图1所示： 随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。【当然也可以修改DBUtil类的源代码，同样会违反开闭原则。】 现使用合成复用原则对其进行重构，重构后的结构如图2所示： 在图2中，CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中，可以使用构造注入，也可以使用Setter注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式。 迪米特法则迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目。迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)，其定义如下： 迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 迪米特法则还有几种定义形式，包括：不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其朋友包括以下几类： 当前对象本身(this)； 以参数形式传入到当前对象方法中的对象； 当前对象的成员对象； 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 下面通过一个简单实例来加深对迪米特法则的理解： Sunny软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如图1所示结构： 在图1中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。 现使用迪米特对其进行重构。 在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后结构如图2所示： 总结通过以上几点设计原则可以得出，要设计出一个具有高可维护、可扩展的系统，应尽量做到以下几点： 类的职责单一：只做一件事情或一类事情，提高代码复用 依赖接口而不是依赖具体实现：针对接口编程而不是实现编程，提高扩展性 子类所有public方法应在基类中声明：使得所有引用基类的地方都能透明的使用子类 尽量使用组合而不是继承扩展某个类的功能： 不要和陌生类发生关系：只和直接朋友发生交互而不和朋友的朋友发生关系，实现解耦 只提供客户需要的：用户需要什么就提高什么，不附加多余功能，提高安全性，避免客户操作不应该操作的。 接口隔离：不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法。使用多个小的专门的接口，而不要使用一个大的总接口。 参考 设计模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://minibox.coding.me/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://minibox.coding.me/tags/设计模式/"}]},{"title":"hexo添加打赏功能","slug":"hexo添加打赏功能","date":"2015-09-21T09:39:00.000Z","updated":"2017-04-24T16:49:50.479Z","comments":true,"path":"2015/09/21/hexo添加打赏功能/","link":"","permalink":"https://minibox.coding.me/2015/09/21/hexo添加打赏功能/","excerpt":"本文将介绍如何在hexo中添加打赏功能 第一步：创建打赏html代码文件首先咱们在主题下layout/commmon文件里，创建一个名叫：donate.ejs的文件在里面输入:","text":"本文将介绍如何在hexo中添加打赏功能 第一步：创建打赏html代码文件首先咱们在主题下layout/commmon文件里，创建一个名叫：donate.ejs的文件在里面输入:12345678910111213141516171819202122&lt;!-- 添加捐赠图标 --&gt;&lt;div class=\"post-donate\" style=\"margin-bottom: 30px;margin-top: 10px;\"&gt; &lt;div id=\"donate_board\" class=\"donate_bar center\"&gt; &lt;a id=\"btn_donate\" class=\"btn_donate\" href=\"javascript:;\" title=\"donate\"&gt;&lt;/a&gt; &lt;span class=\"donate_txt\"&gt; &lt;%=theme.donate_message%&gt; &lt;/span&gt; &lt;br&gt; &lt;/div&gt; &lt;div id=\"donate_guide\" class=\"donate_bar donate_bar2 center hidden\"&gt; &lt;img src=\"/css/images/alipay.jpg\" id=\"weixin\" title=\"alipay doante\" alt=\"alipay doante\"&gt; &lt;img src=\"/css/images/wechatpay.jpg\" title=\"wechatpay donate\" id=\"zhifubao\" alt=\"echatpay donate\"&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; $('#weixin').hover() document.getElementById('btn_donate').onclick = function () &#123; $('#donate_board').addClass('hidden'); $('#donate_guide').removeClass('hidden'); &#125; &lt;/script&gt;&lt;/div&gt; 其中，二维码图片只需放入主题中的source/css/images文件夹内，img的src设置src=”/css/images/alipay.jpg” 第二步：创建打赏css样式文件然后在主题source/css/_partial目录下创建一个相应的css文件donate.styl，输入以下内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374.donate_bar &#123; text-align: center; margin-top: 5%;&#125;.donate_bar2 &#123; z-index: 9999; text-align: center; top: 50%; left: 50%; width: 660px; height: 360px; margin: -180px 0 30px -330px; border-radius: 5px; border: solid 2px #666; background-color: #fff; box-shadow: 0 0 10px #666;&#125;.donate_bar a.btn_donate &#123; display: inline-block; width: 82px; height: 82px; margin-left: auto; margin-right: auto; background: url(/css/images/donate.gif) no-repeat; -webkit-transition: background 0s; -moz-transition: background 0s; -o-transition: background 0s; -ms-transition: background 0s; transition: background 0s&#125;.donate_bar a.btn_donate:hover &#123; background-position: 0 -82px&#125;.donate_bar .donate_txt &#123; display: block; color: #9d9d9d; font: 14px / 2 \"Microsoft Yahei\"&#125;.donate_bar.hidden &#123; display: none&#125;.post-donate &#123; margin-top: 80px;&#125;@media screen and (min-width: 559px) &#123; #donate_guide &#123; height: 210px; width: 420px; margin: 0 auto; &#125;&#125;@media screen and (max-width: 559px) &#123; #donate_guide &#123; height: 420px; width: 210px; margin: 0 auto; &#125;&#125;#donate_guide img &#123; height: 200px; width: 200px;&#125; 注意：以上赏字图片同样放入source/css/images文件夹内，背景图片引用如下方式：1background: url(/css/images/donate.gif) no-repeat; 或者采用外链https方式引用，否则浏览器警报不安全。 第三步：将创建的css文件和ejs文件整合到主题中首先修改主题source/css目录下的style.styl文件，在其中加入@import “_partial/donate”接着，在layout/commmon/article.ejs中，在1&lt;footer class=\"article-footer\"&gt; 前面加入：123&lt;div id=\"donate\" style=\"text-align:center\"&gt; &lt;%- partial('donate') %&gt;&lt;/div&gt; 如果你想自定义一个页面是否带有打赏的地方，则换成以下代码：12345&lt;% if(!index &amp;&amp; theme.donate &amp;&amp; (post.donate || post.donate == undefined))&#123; %&gt; &lt;div id=\"donate\" style=\"text-align:center\"&gt; &lt;%- partial('donate') %&gt; &lt;/div&gt;&lt;% &#125; %&gt; 第四步：编写配置文件在主题配置文件 _config.yml添加打赏相关配置，根据配置 控制文章是否开启打赏功能，还可以自定义设置打赏文案。例如：1234#是否开启打赏donate: true#打赏文案donate_message: 欣赏此文？求鼓励，求支持！ donate为false，则关闭打赏功能，如果要单独控制某篇文章，则donate为true的情况下，新建文章时，只需要在该篇文章上添加 donate: false即可。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://minibox.coding.me/categories/杂谈/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://minibox.coding.me/tags/hexo/"},{"name":"打赏","slug":"打赏","permalink":"https://minibox.coding.me/tags/打赏/"}]}]}